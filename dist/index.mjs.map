{"version":3,"sources":["../src/index.ts","../src/uploader.ts","../src/types.ts","../src/utils.ts"],"sourcesContent":["/**\n * Main entry point for OSS GitHub Action (TypeScript)\n */\n\nimport * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { OSSUploader } from './uploader';\nimport { ActionInputs, OSSConfig, RetryConfig, UploadOptions, UploadResult, UploadStats } from './types';\nimport { validateInputs, parseUploadRules, parseHeaders, formatFileSize, formatDuration, logDebug, isDebugEnabled } from './utils';\n\n/**\n * Main action runner\n */\nasync function run(): Promise<void> {\n  const startTime = Date.now();  try {\n    core.info('üöÄ Starting OSS upload process...');\n\n    if (isDebugEnabled()) {\n      core.info('üêõ ===============================================');\n      core.info('üêõ DEBUG MODE ENABLED - Verbose logging active');\n      core.info('üêõ ===============================================');\n      logDebug('Debug mode enabled', {\n        ACTIONS_STEP_DEBUG: process.env.ACTIONS_STEP_DEBUG,\n        enableDebugInput: core.getInput('enable-debug')\n      });\n    }\n\n    // Get and validate inputs\n    const inputs = getActionInputs();\n    if (isDebugEnabled()) {\n      logDebug('Raw action inputs received', {\n        region: inputs.region,\n        bucket: inputs.bucket,\n        timeout: inputs.timeout,\n        maxRetries: inputs.maxRetries,\n        enableDebug: inputs.enableDebug,\n        assetsLength: inputs.assets.length\n      });\n    }\n    validateInputs(inputs);\n\n    // Create OSS configuration\n    const ossConfig = createOSSConfig(inputs);\n    logDebug('OSS configuration created', {\n      bucket: ossConfig.bucket,\n      region: ossConfig.region,\n      endpoint: ossConfig.endpoint,\n      timeout: ossConfig.timeout\n    });\n    logConnectionInfo(ossConfig);\n\n    // Create retry configuration\n    const retryConfig = createRetryConfig(inputs);\n    logDebug('Retry configuration', retryConfig);\n\n    // Create upload options\n    const uploadOptions = createUploadOptions(inputs);\n    logDebug('Upload options', uploadOptions);\n\n    // Initialize uploader\n    const uploader = new OSSUploader(ossConfig, retryConfig);\n\n    // Test connection (optional)\n    const connectionOk = await uploader.testConnection();\n    if (!connectionOk) {\n      core.warning('‚ö†Ô∏è  OSS connection test failed, but continuing with upload...');\n    }\n\n    // Parse upload rules\n    const rules = parseUploadRules(inputs.assets);\n    logDebug('Parsed upload rules', rules);\n    if (rules.length === 0) {\n      core.setFailed('No valid upload rules found in assets input');\n      return;\n    }\n\n    core.info(`üìã Processing ${rules.length} upload rule(s)`);\n\n    // Perform uploads\n    const results = await uploader.uploadFiles(rules, uploadOptions);\n    const stats = uploader.getStats();\n    logDebug('Upload results', { results, stats });\n\n    // Set outputs\n    await setActionOutputs(results, stats, ossConfig);\n\n    // Create job summary\n    await createJobSummary(stats, ossConfig, startTime);\n\n    // Check if we should fail on incomplete uploads\n    const continueOnError = inputs.continueOnError === 'true';\n    if (!continueOnError && stats.failedFiles > 0) {\n      core.setFailed(`Upload incomplete: ${stats.failedFiles} file(s) failed to upload`);\n      return;\n    }\n\n    const totalTime = formatDuration(Date.now() - startTime);\n    core.info(`üéâ Action completed successfully in ${totalTime}`);\n\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n    core.error(`üí• Action failed: ${errorMessage}`);\n    core.setFailed(errorMessage);\n  }\n}\n\n/**\n * Extract and parse action inputs\n */\nfunction getActionInputs(): ActionInputs {\n  return {\n    accessKey: core.getInput('access-key', { required: true }),\n    secretKey: core.getInput('secret-key', { required: true }),\n    bucket: core.getInput('bucket', { required: true }),\n    assets: core.getInput('assets', { required: true }),\n    region: core.getInput('region') || undefined,\n    endpoint: core.getInput('endpoint') || undefined,\n    timeout: core.getInput('timeout') || '120',\n    maxRetries: core.getInput('max-retries') || '3',\n    continueOnError: core.getInput('continue-on-error') || 'false',\n    enableGzip: core.getInput('enable-gzip') || 'false',\n    publicRead: core.getInput('public-read') || 'false',\n    headers: core.getInput('headers') || undefined,\n    enableDebug: core.getInput('enable-debug') || 'false'\n  };\n}\n\n/**\n * Create OSS configuration from inputs\n */\nfunction createOSSConfig(inputs: ActionInputs): OSSConfig {\n  const config: OSSConfig = {\n    accessKeyId: inputs.accessKey,\n    accessKeySecret: inputs.secretKey,\n    bucket: inputs.bucket,\n    timeout: parseInt(inputs.timeout || '600', 10) * 1000 // Convert to milliseconds\n  };\n\n  if (inputs.region) {\n    config.region = inputs.region;\n  }\n\n  if (inputs.endpoint) {\n    config.endpoint = inputs.endpoint;\n  }\n\n  return config;\n}\n\n/**\n * Create retry configuration from inputs\n */\nfunction createRetryConfig(inputs: ActionInputs): RetryConfig {\n  return {\n    maxRetries: parseInt(inputs.maxRetries || '3', 10),\n    baseDelay: 1000,\n    maxDelay: 10000,\n    backoffMultiplier: 2\n  };\n}\n\n/**\n * Create upload options from inputs\n */\nfunction createUploadOptions(inputs: ActionInputs): UploadOptions {\n  const options: UploadOptions = {\n    timeout: parseInt(inputs.timeout || '600', 10) * 1000\n  };\n\n  // Parse custom headers\n  const customHeaders = parseHeaders(inputs.headers);\n  if (Object.keys(customHeaders).length > 0) {\n    options.headers = customHeaders;\n  }\n\n  // Enable gzip compression\n  if (inputs.enableGzip === 'true') {\n    options.gzip = true;\n  }\n\n  // Set public read ACL\n  if (inputs.publicRead === 'true') {\n    options['x-oss-object-acl'] = 'public-read';\n  }\n\n  return options;\n}\n\n/**\n * Log connection information\n */\nfunction logConnectionInfo(config: OSSConfig): void {\n  core.info(`üì¶ Connecting to OSS bucket: ${config.bucket}`);\n  if (config.region) core.info(`üåç Region: ${config.region}`);\n  if (config.endpoint) core.info(`üîó Endpoint: ${config.endpoint}`);\n  core.info(`‚è±Ô∏è Timeout: ${config.timeout / 1000}s`);\n}\n\n/**\n * Set GitHub Action outputs\n */\nasync function setActionOutputs(results: UploadResult[], stats: UploadStats, config: OSSConfig): Promise<void> {\n  // Set URL outputs only if there are results\n  if (results.length > 0) {\n    core.setOutput('url', results.map(r => r.url).join(','));\n    core.setOutput('urls', JSON.stringify(results.map(r => r.url)));\n  } else {\n    core.setOutput('url', '');\n    core.setOutput('urls', JSON.stringify([]));\n  }\n\n  // Always set stats and config outputs\n  core.setOutput('count', stats.uploadedFiles.toString());\n  core.setOutput('total-files', stats.totalFiles.toString());\n  core.setOutput('uploaded-files', stats.uploadedFiles.toString());\n  core.setOutput('failed-files', stats.failedFiles.toString());\n  core.setOutput('total-size', stats.totalSize.toString());\n  core.setOutput('uploaded-size', stats.uploadedSize.toString());\n  core.setOutput('success-rate', stats.successRate.toFixed(1));\n  core.setOutput('duration', stats.totalDuration.toString());\n\n  // Set bucket info\n  core.setOutput('bucket', config.bucket);\n  core.setOutput('region', config.region || 'default');\n}\n\n/**\n * Create detailed job summary\n */\nasync function createJobSummary(stats: UploadStats, config: OSSConfig, startTime: number): Promise<void> {\n  const totalTime = formatDuration(Date.now() - startTime);\n  const totalSize = formatFileSize(stats.totalSize);\n  const uploadedSize = formatFileSize(stats.uploadedSize);\n\n  await core.summary\n    .addHeading('OSS Upload Summary üì¶')\n    .addTable([\n      [{data: 'Metric', header: true}, {data: 'Value', header: true}],\n      ['Total Files Found', stats.totalFiles.toString()],\n      ['Files Uploaded', stats.uploadedFiles.toString()],\n      ['Files Failed', stats.failedFiles.toString()],\n      ['Success Rate', `${stats.successRate.toFixed(1)}%`],\n      ['Total Size', totalSize],\n      ['Uploaded Size', uploadedSize],\n      ['Total Time', totalTime],\n      ['Bucket', config.bucket],\n      ['Region', config.region || 'default']\n    ])\n    .addDetails('GitHub Action Context', [\n      `**Repository**: ${github.context.repo.owner}/${github.context.repo.repo}`,\n      `**Workflow**: ${github.context.workflow}`,\n      `**Run ID**: ${github.context.runId}`,\n      `**SHA**: ${github.context.sha.substring(0, 7)}`\n    ].join('\\n'))\n    .write();\n}\n\n// Run the action\n// In ES modules, check if this is the main entry point\nif (import.meta.url === `file://${process.argv[1]}`) {\n  run().catch(error => {\n    core.setFailed(error instanceof Error ? error.message : 'Unknown error');\n    process.exit(1);\n  });\n}\n\nexport { run };\n","/**\n * OSS Uploader class with retry logic and better error handling\n */\n\nimport OSS from 'ali-oss';\nimport { resolve, basename } from 'path';\nimport * as core from '@actions/core';\nimport * as fg from 'fast-glob';\nimport { existsSync, statSync } from 'fs';\nimport {\n  OSSConfig,\n  UploadRule,\n  UploadResult,\n  UploadStats,\n  RetryConfig,\n  UploadOptions,\n  OSSResponse,\n  OSSSDKError,\n  NetworkError,\n  FileNotFoundError\n} from './types';\nimport {\n  formatFileSize,\n  formatDuration,\n  calculateBackoffDelay,\n  getFileStats,\n  sanitizeRemotePath,\n  extractRelativePath,\n  delay,\n  logOperation,\n  logSuccess,\n  logWarning,\n  logError,\n  logDebug\n} from './utils';\n\nexport class OSSUploader {\n  private oss: OSS;\n  private retryConfig: RetryConfig;\n  private stats: UploadStats;\n  private config: OSSConfig;\n\n  constructor(\n    config: OSSConfig,\n    retryConfig: RetryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffMultiplier: 2\n    }\n  ) {\n    this.config = config;\n    this.oss = new OSS(config);\n    this.retryConfig = retryConfig;\n    this.stats = {\n      totalFiles: 0,\n      uploadedFiles: 0,\n      failedFiles: 0,\n      totalSize: 0,\n      uploadedSize: 0,\n      totalDuration: 0,\n      successRate: 0\n    };\n  }\n\n  /**\n   * Upload files based on rules with retry logic\n   */\n  async uploadFiles(rules: UploadRule[], options: UploadOptions = {}): Promise<UploadResult[]> {\n    const results: UploadResult[] = [];\n    const startTime = Date.now();\n\n    logOperation('Starting upload process', `${rules.length} rule(s)`);\n    logDebug('Upload process started', { rulesCount: rules.length, options });\n\n    for (const rule of rules) {\n      try {\n        logDebug('Processing upload rule', { rule, ruleIndex: rules.indexOf(rule) + 1 });\n        const ruleResults = await this.processRule(rule, options);\n        results.push(...ruleResults);\n        logDebug('Rule processing completed', {\n          rule: rule.source + ' ‚Üí ' + rule.destination,\n          resultCount: ruleResults.length\n        });\n      } catch (error) {\n        logError(`Failed to process rule: ${rule.source} ‚Üí ${rule.destination}`);\n        logDebug('Rule processing failed', { rule, error: error instanceof Error ? error.message : error });\n        if (error instanceof Error) {\n          core.error(error.message);\n        }\n        this.stats.failedFiles++;\n      }\n    }\n\n    this.stats.totalDuration = Date.now() - startTime;\n    this.stats.successRate = this.stats.totalFiles > 0\n      ? (this.stats.uploadedFiles / this.stats.totalFiles) * 100\n      : 0;\n\n    this.logFinalStats();\n    return results;\n  }\n\n  /**\n   * Process a single upload rule\n   */\n  private async processRule(rule: UploadRule, options: UploadOptions): Promise<UploadResult[]> {\n    logOperation(`Processing rule`, `${rule.source} ‚Üí ${rule.destination}`);\n    logDebug('Processing upload rule', rule);\n\n    // For directory uploads, ensure source pattern includes glob to find all files\n    // But first check if the source is actually a file - if so, don't convert to directory pattern\n    let sourcePattern = rule.source;\n    if (rule.isDirectory && !sourcePattern.includes('*') && !sourcePattern.includes('?') && !sourcePattern.includes('[')) {\n      // Check if the source path exists and is a file\n      if (existsSync(sourcePattern) && statSync(sourcePattern).isFile()) {\n        // Source is a file but destination is a directory - this is valid (single file to directory)\n        // Don't modify the source pattern\n      } else {\n        // Source is not a file or doesn't exist, treat as directory pattern\n        sourcePattern = sourcePattern.endsWith('/') ? `${sourcePattern}**/*` : `${sourcePattern}/**/*`;\n        logOperation(`Converted directory pattern`, `${rule.source} ‚Üí ${sourcePattern}`);\n      }\n    }\n\n    logDebug('Searching for files with pattern', sourcePattern);\n    const files = fg.sync([sourcePattern], {\n      dot: false,\n      onlyFiles: true,\n      absolute: true\n    });\n    logDebug('Found files', { pattern: sourcePattern, count: files.length, files });\n\n    // Check if this is a specific file path that doesn't exist\n    // (as opposed to a glob pattern that legitimately finds no files)\n    const isSpecificFile = !sourcePattern.includes('*') && !sourcePattern.includes('?') && !sourcePattern.includes('[');\n\n    if (files.length === 0) {\n      if (isSpecificFile) {\n        // This is a specific file that doesn't exist - count as a failure\n        logError(`File not found: ${rule.source}`);\n        this.stats.totalFiles += 1;\n        this.stats.failedFiles += 1;\n        return [];\n      } else {\n        // This is a glob pattern that found no files - not an error\n        logWarning(`No files found matching pattern: ${sourcePattern}`);\n        return [];\n      }\n    }\n\n    this.stats.totalFiles += files.length;\n    logOperation(`Found ${files.length} file(s) to upload`);\n\n    const results: UploadResult[] = [];\n\n    if (!rule.isDirectory) {\n      // Single file upload\n      if (files.length > 1) {\n        logWarning(`Multiple files found but destination is single file. Using first file: ${files[0]}`);\n      }\n\n      const result = await this.uploadSingleFile(files[0], rule.destination, options);\n      if (result) results.push(result);\n    } else {\n      // Directory upload - process files sequentially\n      for (const file of files) {\n        let remotePath: string;\n\n        // Check if this is a single file being uploaded to a directory destination\n        if (files.length === 1 && !rule.source.includes('*') && !rule.source.includes('?') && !rule.source.includes('[')) {\n          // Single file to directory - use just the filename\n          const filename = basename(file);\n          remotePath = sanitizeRemotePath(`${rule.destination}${filename}`);\n        } else {\n          // Multiple files or glob pattern - use relative path extraction\n          const relativePath = extractRelativePath(file, rule.source);\n          remotePath = sanitizeRemotePath(`${rule.destination}${relativePath}`);\n        }\n\n        const result = await this.uploadSingleFile(file, remotePath, options);\n        if (result) results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Upload a single file with retry logic\n   */\n  private async uploadSingleFile(\n    localPath: string,\n    remotePath: string,\n    options: UploadOptions\n  ): Promise<UploadResult | null> {\n    try {\n      logDebug('Starting single file upload', { localPath, remotePath });\n      const fileStats = await getFileStats(localPath);\n      this.stats.totalSize += fileStats.size;\n      logDebug('File stats obtained', { localPath, size: fileStats.size, name: fileStats.name });\n\n      const result = await this.uploadWithRetry(\n        () => this.performUpload(localPath, remotePath, options),\n        localPath,\n        fileStats\n      );\n\n      if (result) {\n        this.stats.uploadedFiles++;\n        this.stats.uploadedSize += fileStats.size;\n      }\n\n      return result;\n    } catch (error) {\n      this.stats.failedFiles++;\n      logError(`Failed to upload ${localPath}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n\n      // Re-throw if it's a critical error\n      if (error instanceof FileNotFoundError) {\n        throw error;\n      }\n\n      return null;\n    }\n  }\n\n  /**\n   * Perform the actual upload with OSS\n   */\n  private async performUpload(\n    localPath: string,\n    remotePath: string,\n    options: UploadOptions\n  ): Promise<UploadResult> {\n    logDebug('Performing OSS upload', { localPath, remotePath, options });\n\n    const uploadOptions: Record<string, unknown> = {\n      timeout: options.timeout || 600000,\n      ...options\n    };\n\n    // Handle gzip compression\n    if (options.gzip) {\n      uploadOptions.headers = {\n        ...(uploadOptions.headers as Record<string, string> || {}),\n        'Content-Encoding': 'gzip'\n      };\n    }\n\n    const response = await this.oss.put(remotePath, resolve(localPath), uploadOptions);\n    logDebug('OSS upload response received', { remotePath, responseStatus: response?.res?.status });\n\n    // Handle OSS response structure safely\n    const ossResponse = response as unknown as OSSResponse;\n    const fileStats = await getFileStats(localPath);\n\n    const result = {\n      success: true,\n      filePath: localPath,\n      objectKey: remotePath,\n      size: fileStats.size,\n      ...(ossResponse.res?.headers?.etag && { etag: ossResponse.res.headers.etag }),\n      ...(ossResponse.url && { url: ossResponse.url })\n    };\n\n    logDebug('Upload result created', result);\n    return result;\n  }\n\n  /**\n   * Upload with retry logic and exponential backoff\n   */\n  private async uploadWithRetry(\n    uploadFn: () => Promise<UploadResult>,\n    _filePath: string,\n    fileStats: { size: number; name: string }\n  ): Promise<UploadResult | null> {\n    const fileSizeFormatted = formatFileSize(fileStats.size);\n    logDebug('Starting upload with retry', { fileName: fileStats.name, size: fileSizeFormatted, maxRetries: this.retryConfig.maxRetries });\n\n    for (let attempt = 0; attempt < this.retryConfig.maxRetries; attempt++) {\n      try {\n        const retryLabel = attempt > 0 ? ` - Retry ${attempt}` : '';\n        logOperation(`‚¨ÜÔ∏è  Uploading ${fileStats.name} (${fileSizeFormatted})${retryLabel}`);\n        logDebug('Upload attempt', { attempt: attempt + 1, fileName: fileStats.name });\n\n        const startTime = Date.now();\n        const result = await uploadFn();\n        const duration = Date.now() - startTime;\n\n        logSuccess(`Uploaded ${fileStats.name} in ${formatDuration(duration)}`);\n        logDebug('Upload successful', { fileName: fileStats.name, duration, attempt: attempt + 1 });\n        return result;\n\n      } catch (error: unknown) {\n        const isLastAttempt = attempt === this.retryConfig.maxRetries - 1;\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n        logWarning(`Upload failed for ${fileStats.name}: ${errorMessage}`);\n        logDebug('Upload attempt failed', { fileName: fileStats.name, attempt: attempt + 1, error: errorMessage, isLastAttempt });\n\n        // Convert to Error for the retry check\n        const errorObj = error instanceof Error ? error : new Error(String(error));\n\n        // Check if it's a retryable error\n        if (!this.isRetryableError(errorObj) || isLastAttempt) {\n          if (isLastAttempt) {\n            logError(`üí• All ${this.retryConfig.maxRetries} attempts failed for ${fileStats.name}`);\n          }\n          throw errorObj;\n        }\n\n        // Calculate backoff delay\n        const delayMs = calculateBackoffDelay(\n          attempt,\n          this.retryConfig.baseDelay,\n          this.retryConfig.maxDelay,\n          this.retryConfig.backoffMultiplier\n        );\n\n        logOperation(`‚è≥ Retrying in ${formatDuration(delayMs)}... (attempt ${attempt + 2}/${this.retryConfig.maxRetries})`);\n        logDebug('Retry delay calculated', { delayMs, attempt, fileName: fileStats.name });\n        await delay(delayMs);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if an error is retryable\n   */\n  private isRetryableError(error: Error): boolean {\n    if (error instanceof FileNotFoundError) {\n      return false; // File not found is not retryable\n    }\n\n    // Network-related errors are retryable\n    if (error instanceof NetworkError) {\n      return true;\n    }\n\n    // OSS SDK specific errors\n    const ossError = error as Error & OSSSDKError;\n    if (ossError.code) {\n      const retryableCodes = [\n        'RequestTimeout',\n        'ServiceUnavailable',\n        'Throttling',\n        'InternalError',\n        'ConnectionTimeout',\n        'SocketTimeout'\n      ];\n      return retryableCodes.includes(ossError.code);\n    }\n\n    // HTTP status codes that are retryable\n    if (ossError.status) {\n      const retryableStatuses = [408, 429, 500, 502, 503, 504];\n      return retryableStatuses.includes(ossError.status);\n    }\n\n    // Timeout errors\n    if (error.message && error.message.toLowerCase().includes('timeout')) {\n      return true;\n    }\n\n    // Default to retryable for unknown errors\n    return true;\n  }\n\n  /**\n   * Get current upload statistics\n   */\n  getStats(): UploadStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Log final upload statistics\n   */\n  private logFinalStats(): void {\n    const duration = formatDuration(this.stats.totalDuration);\n    const totalSize = formatFileSize(this.stats.totalSize);\n    const uploadedSize = formatFileSize(this.stats.uploadedSize);\n\n    logSuccess(\n      `Upload completed! ${this.stats.uploadedFiles}/${this.stats.totalFiles} files ` +\n      `(${uploadedSize}/${totalSize}) uploaded in ${duration}`\n    );\n\n    if (this.stats.failedFiles > 0) {\n      logWarning(`${this.stats.failedFiles} file(s) failed to upload`);\n    }\n  }\n\n  /**\n   * Test OSS connection\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      logDebug('Testing OSS connection', { bucket: this.config.bucket, region: this.config.region });\n      await this.oss.getBucketInfo(this.config.bucket);\n      logSuccess('OSS connection test successful');\n      logDebug('OSS connection test details', { bucket: this.config.bucket, status: 'success' });\n      return true;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logError(`OSS connection test failed: ${errorMessage}`);\n      logDebug('OSS connection test failed', { bucket: this.config.bucket, error: errorMessage });\n      return false;\n    }\n  }\n}\n","export interface OSSConfig {\n  accessKeyId: string;\n  accessKeySecret: string;\n  bucket: string;\n  region?: string;\n  endpoint?: string;\n  timeout: number;\n  secure?: boolean;\n  cname?: boolean;\n}\n\nexport interface UploadRule {\n  source: string;\n  destination: string;\n  isDirectory: boolean;\n}\n\nexport interface UploadResult {\n  success: boolean;\n  filePath: string;\n  objectKey: string;\n  size: number;\n  etag?: string;\n  url?: string;\n  error?: string;\n}\n\nexport interface UploadStats {\n  totalFiles: number;\n  uploadedFiles: number;\n  failedFiles: number;\n  totalSize: number;\n  uploadedSize: number;\n  totalDuration: number;\n  successRate: number;\n}\n\nexport interface ActionInputs {\n  accessKey: string;\n  secretKey: string;\n  bucket: string;\n  assets: string;\n  region?: string | undefined;\n  endpoint?: string | undefined;\n  timeout?: string | undefined;\n  maxRetries?: string | undefined;\n  continueOnError?: string | undefined;\n  enableGzip?: string | undefined;\n  publicRead?: string | undefined;\n  headers?: string | undefined;\n  enableDebug?: string | undefined;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n}\n\nexport interface UploadOptions {\n  timeout?: number;\n  headers?: Record<string, string>;\n  gzip?: boolean;\n  'x-oss-storage-class'?: 'Standard' | 'IA' | 'Archive' | 'ColdArchive';\n  'x-oss-object-acl'?: 'private' | 'public-read' | 'public-read-write';\n  meta?: Record<string, string>;\n}\n\nexport class OSSActionError extends Error {\n  public readonly code?: string;\n  public readonly statusCode?: number;\n  public readonly filePath?: string;\n\n  constructor(\n    message: string,\n    code?: string,\n    statusCode?: number,\n    filePath?: string\n  ) {\n    super(message);\n    this.name = 'OSSActionError';\n    if (code !== undefined) this.code = code;\n    if (statusCode !== undefined) this.statusCode = statusCode;\n    if (filePath !== undefined) this.filePath = filePath;\n  }\n}\n\nexport class ValidationError extends OSSActionError {\n  constructor(message: string) {\n    super(`Validation Error: ${message}`, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n  }\n}\n\nexport class NetworkError extends OSSActionError {\n  constructor(message: string, statusCode?: number) {\n    super(`Network Error: ${message}`, 'NETWORK_ERROR', statusCode);\n    this.name = 'NetworkError';\n  }\n}\n\nexport class FileNotFoundError extends OSSActionError {\n  constructor(filePath: string) {\n    super(`File not found: ${filePath}`, 'FILE_NOT_FOUND', undefined, filePath);\n    this.name = 'FileNotFoundError';\n  }\n}\n\nexport interface OSSResponse {\n  res?: {\n    headers?: {\n      etag?: string;\n    };\n  };\n  url?: string;\n}\n\nexport interface OSSSDKError {\n  code?: string;\n  status?: number;\n  message?: string;\n}\n","/**\n * Utility functions for OSS Action\n */\n\nimport { promises as fs } from 'fs';\nimport { basename } from 'path';\nimport * as core from '@actions/core';\nimport { ValidationError, FileNotFoundError, UploadRule, ActionInputs } from './types';\n\n/**\n * Validates required GitHub Action inputs\n */\nexport function validateInputs(inputs: ActionInputs): void {\n  const requiredFields = ['accessKey', 'secretKey', 'bucket', 'assets'];\n\n  for (const field of requiredFields) {\n    if (!inputs[field as keyof ActionInputs]) {\n      throw new ValidationError(`Required input '${field}' is missing`);\n    }\n  }\n\n  // Validate timeout\n  if (inputs.timeout) {\n    const timeout = parseInt(inputs.timeout, 10);\n    if (isNaN(timeout) || timeout <= 0) {\n      throw new ValidationError('Timeout must be a positive number');\n    }\n  }\n\n  // Validate maxRetries\n  if (inputs.maxRetries) {\n    const retries = parseInt(inputs.maxRetries, 10);\n    if (isNaN(retries) || retries < 0) {\n      throw new ValidationError('Max retries must be a non-negative number');\n    }\n  }\n}\n\n/**\n * Parses upload rules from assets string\n */\nexport function parseUploadRules(assets: string): UploadRule[] {\n  const rules: UploadRule[] = [];\n\n  for (const line of assets.split('\\n')) {\n    const trimmed = line.trim();\n    if (!trimmed) continue;\n\n    const [source, destination] = trimmed.split(':');\n    if (!source || !destination) {\n      core.warning(`‚ö†Ô∏è  Skipping invalid rule: ${trimmed}`);\n      continue;\n    }\n\n    rules.push({\n      source: source.trim(),\n      destination: destination.trim(),\n      isDirectory: destination.trim().endsWith('/')\n    });\n  }\n\n  return rules;\n}\n\n/**\n * Formats file size in human-readable format\n */\nexport function formatFileSize(bytes: number): string {\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let size = bytes;\n  let unitIndex = 0;\n\n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n\n  return `${size.toFixed(2)} ${units[unitIndex]}`;\n}\n\n/**\n * Formats duration in human-readable format\n */\nexport function formatDuration(milliseconds: number): string {\n  const seconds = milliseconds / 1000;\n\n  if (seconds < 60) {\n    return `${seconds.toFixed(1)}s`;\n  } else if (seconds < 3600) {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;\n  } else {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    return `${hours}h ${minutes}m`;\n  }\n}\n\n/**\n * Calculates exponential backoff delay\n */\nexport function calculateBackoffDelay(\n  attempt: number,\n  baseDelay: number = 1000,\n  maxDelay: number = 10000,\n  multiplier: number = 2\n): number {\n  const delay = baseDelay * Math.pow(multiplier, attempt);\n  return Math.min(delay, maxDelay);\n}\n\n/**\n * Validates if file exists and is readable\n */\nexport async function validateFile(filePath: string): Promise<void> {\n  try {\n    const stats = await fs.stat(filePath);\n    if (!stats.isFile()) {\n      throw new FileNotFoundError(`Path is not a file: ${filePath}`);\n    }\n  } catch (error: unknown) {\n    const nodeError = error as { code?: string };\n    if (nodeError.code === 'ENOENT') {\n      throw new FileNotFoundError(filePath);\n    }\n    throw error;\n  }\n}\n\n/**\n * Gets file stats safely\n */\nexport async function getFileStats(filePath: string): Promise<{ size: number; name: string }> {\n  await validateFile(filePath);\n  const stats = await fs.stat(filePath);\n  return {\n    size: stats.size,\n    name: basename(filePath)\n  };\n}\n\n/**\n * Parses custom headers from string\n */\nexport function parseHeaders(headersString?: string): Record<string, string> {\n  if (!headersString) return {};\n\n  try {\n    return JSON.parse(headersString);\n  } catch {\n    core.warning(`‚ö†Ô∏è  Failed to parse headers JSON: ${headersString}`);\n    return {};\n  }\n}\n\n/**\n * Sanitizes remote path to ensure it's valid\n */\nexport function sanitizeRemotePath(path: string): string {\n  // Remove leading slashes and normalize\n  return path.replace(/^\\/+/, '').replace(/\\/+/g, '/');\n}\n\n/**\n * Creates a delay promise for retry backoff\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Extracts relative path from a file path based on glob pattern\n */\nexport function extractRelativePath(filePath: string, basePath: string): string {\n  // Remove glob patterns and normalize the base path\n  const base = basePath.replace(/\\*+.*$/g, '').replace(/\\/$/, '');\n\n  // If the file path starts with the base, extract the relative part\n  if (filePath.startsWith(base)) {\n    const relativePath = filePath.substring(base.length);\n    // Remove leading slash if present\n    return relativePath.startsWith('/') ? relativePath.substring(1) : relativePath;\n  }\n\n  // Fallback: just return the filename\n  return filePath.split('/').pop() || filePath;\n}\n\n/**\n * Logs operation with consistent formatting\n */\nexport function logOperation(operation: string, details?: string): void {\n  const message = details ? `${operation}: ${details}` : operation;\n  core.info(`üîß ${message}`);\n}\n\n/**\n * Logs success with consistent formatting\n */\nexport function logSuccess(message: string): void {\n  core.info(`‚úÖ ${message}`);\n}\n\n/**\n * Logs warning with consistent formatting\n */\nexport function logWarning(message: string): void {\n  core.warning(`‚ö†Ô∏è  ${message}`);\n}\n\n/**\n * Logs error with consistent formatting\n */\nexport function logError(message: string): void {\n  core.error(`‚ùå ${message}`);\n}\n\n/**\n * Logs debug information (visible when debug mode is enabled)\n *\n * Note: We use core.info() instead of core.debug() because:\n * - core.debug() often doesn't appear even in raw logs due to GitHub Actions limitations\n * - Runner-level filtering and action context issues can suppress debug output\n * - Using core.info() with conditional checking provides better visibility and control\n */\nexport function logDebug(message: string, details?: any): void {\n  if (!isDebugEnabled()) {\n    return;\n  }\n\n  if (details && typeof details === 'object') {\n    // Use core.info() instead of core.debug() for better visibility\n    core.info(`üêõ DEBUG: ${message}: ${JSON.stringify(details, null, 2)}`);\n  } else if (details !== undefined) {\n    core.info(`üêõ DEBUG: ${message}: ${details}`);\n  } else {\n    core.info(`üêõ DEBUG: ${message}`);\n  }\n}\n\n/**\n * Checks if debug mode is enabled\n */\nexport function isDebugEnabled(): boolean {\n  // Check environment variable first (GitHub Actions standard)\n  if (process.env.ACTIONS_STEP_DEBUG === 'true') {\n    return true;\n  }\n\n  // Check action input (our custom option)\n  try {\n    return core.getInput('enable-debug') === 'true';\n  } catch {\n    // If core.getInput fails (e.g., in tests), default to false\n    return false;\n  }\n}\n"],"mappings":"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","names":["core","github","OSS","resolve","basename","core","fg","existsSync","statSync","OSSActionError","message","code","statusCode","filePath","ValidationError","NetworkError","FileNotFoundError","fs","basename","core","validateInputs","inputs","requiredFields","field","ValidationError","timeout","retries","parseUploadRules","assets","rules","line","trimmed","source","destination","formatFileSize","bytes","units","size","unitIndex","formatDuration","milliseconds","seconds","minutes","remainingSeconds","hours","calculateBackoffDelay","attempt","baseDelay","maxDelay","multiplier","delay","validateFile","filePath","fs","FileNotFoundError","error","getFileStats","basename","parseHeaders","headersString","sanitizeRemotePath","path","ms","resolve","extractRelativePath","basePath","base","relativePath","logOperation","operation","details","message","logSuccess","logWarning","logError","logDebug","isDebugEnabled","OSSUploader","config","retryConfig","OSS","rules","options","results","startTime","logOperation","logDebug","rule","ruleResults","error","logError","sourcePattern","existsSync","statSync","files","isSpecificFile","logWarning","file","remotePath","filename","basename","sanitizeRemotePath","relativePath","extractRelativePath","result","localPath","fileStats","getFileStats","FileNotFoundError","uploadOptions","response","resolve","ossResponse","uploadFn","_filePath","fileSizeFormatted","formatFileSize","attempt","retryLabel","duration","logSuccess","formatDuration","isLastAttempt","errorMessage","errorObj","delayMs","calculateBackoffDelay","delay","NetworkError","ossError","totalSize","uploadedSize","run","startTime","isDebugEnabled","logDebug","inputs","getActionInputs","validateInputs","ossConfig","createOSSConfig","logConnectionInfo","retryConfig","createRetryConfig","uploadOptions","createUploadOptions","uploader","OSSUploader","rules","parseUploadRules","results","stats","setActionOutputs","createJobSummary","totalTime","formatDuration","error","errorMessage","config","options","customHeaders","parseHeaders","r","totalSize","formatFileSize","uploadedSize"]}